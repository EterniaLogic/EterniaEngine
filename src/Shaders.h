// Auto-generated cshader from '../shaders_/'
#ifndef SHADERSx_H_
#define SHADERSx_H_


namespace GEN_Shaders {
    static const char * BasicParticles_Fragment[] = { " #ifdef GL_ES\n precision mediump float;\n #endif\n \n void main(void)\n {\n float alpha = 1.0-length((gl_PointCoord-0.5)*2.0);\n gl_FragColor = vec4(1.0,1.0,1.0,alpha);\n }\n" };

    static const char * BasicParticles[] = { " attribute vec3 vertex;\n \n uniform mat4 _mvProj;\n uniform float pointSize;\n \n void main(void) {\n gl_Position = _mvProj * vec4(vertex, 1.0);\n gl_PointSize = pointSize / gl_Position.w;\n }\n" };

    static const char * BumpMap_Fragment[] = { " #define MAX_LIGHTS 8\n #define NUM_LIGHTS 3\n varying vec3 lightVec[MAX_LIGHTS];\n varying vec3 viewVec;\n uniform sampler2D colorMap;\n uniform sampler2D normalMap;\n void main (void)\n {\n vec2 uv = gl_TexCoord[0].st * 4.0;\n vec4 base = texture2D(colorMap, uv);\n vec4 final_color = vec4(0.2, 0.2, 0.2, 1.0) * base;\n vec3 vVec = normalize(viewVec);\n vec3 bump =\n normalize(texture2D(normalMap, uv).xyz * 2.0 - 1.0);\n vec3 R = reflect(-vVec, bump);\n int i;\n for (i=0; i<NUM_LIGHTS; ++i)\n {\n vec3 lVec = normalize(lightVec[i]);\n float diffuse = max(dot(lVec, bump), 0.0);\n vec4 vDiffuse =\n gl_FrontLightProduct[i].diffuse *\n diffuse * base;\n final_color += vDiffuse;\n \n float specular =\n pow(clamp(dot(R, lVec), 0.0, 1.0),\n gl_FrontMaterial.shininess);\n vec4 vSpecular =\n gl_FrontLightProduct[i].specular *\n specular * diffuse;\n final_color += vSpecular;\n }\n \n gl_FragColor = final_color;\n }\n" };

    static const char * BumpMap[] = { " #define MAX_LIGHTS 8\n #define NUM_LIGHTS 3\n varying vec3 lightVec[MAX_LIGHTS];\n varying vec3 viewVec;\n attribute vec4 glTangent4f;\n void main(void)\n {\n gl_Position = ftransform();\n gl_TexCoord[0] = gl_MultiTexCoord0;\n \n vec3 n = normalize(gl_NormalMatrix * gl_Normal);\n vec3 t = normalize(gl_NormalMatrix * glTangent4f.xyz);\n vec3 b = cross(n, t);\n \n vec3 v;\n vec3 vVertex = vec3(gl_ModelViewMatrix * gl_Vertex);\n int i;\n for (i=0; i<NUM_LIGHTS; ++i)\n {\n vec3 lVec = gl_LightSource[i].position.xyz - vVertex;\n v.x = dot(lVec, t);\n v.y = dot(lVec, b);\n v.z = dot(lVec, n);\n lightVec[i] = v;\n }\n \n vec3 vVec = -vVertex;\n v.x = dot(vVec, t);\n v.y = dot(vVec, b);\n v.z = dot(vVec, n);\n viewVec = v;\n }\n" };

    static const char * Light_Fragment[] = { " varying vec3 N;\n varying vec3 v;\n \n void main (void)\n {\n vec3 L = normalize(gl_LightSource[0].position.xyz - v);\n vec3 E = normalize(-v); // we are in Eye Coordinates, so EyePos is (0,0,0)\n vec3 R = normalize(-reflect(L,N));\n \n //calculate Ambient Term:\n vec4 Iamb = gl_FrontLightProduct[0].ambient;\n \n //calculate Diffuse Term:\n vec4 Idiff = gl_FrontLightProduct[0].diffuse * max(dot(N,L), 0.0);\n \n // calculate Specular Term:\n vec4 Ispec = gl_FrontLightProduct[0].specular\n * pow(max(dot(R,E),0.0),0.3*gl_FrontMaterial.shininess);\n \n // write Total Color:\n //gl_FragColor = gl_FrontLightModelProduct.sceneColor + Iamb + Idiff + Ispec;\n gl_FragColor = vec4(1,1,1,1);\n }\n" };

    static const char * Lighting_Fragment[] = { " uniform vec3 ambient;\n uniform vec3 diffuse;\n uniform vec3 specc;\n uniform vec3 lightloc;\n \n const float precis = 0.0001;\n \n \n \n vec3 getNormal( vec3 p ){\n float e = precis;\n return normalize( vec3( map( vec3( p.x + e, p.y, p.z ) ).x - map(  vec3( p.x - e, p.y, p.z ) ).x,\n map( vec3( p.x, p.y + e, p.z ) ).x - map( vec3( p.x, p.y - e, p.z ) ).x,\n map( vec3( p.x, p.y, p.z + e ) ).x - map( vec3( p.x, p.y, p.z - e ) ).x ) );\n }\n \n float raymarching( vec3 ro, vec3 rd ){\n float res = -1.0;\n float tmin = 1.0;\n float tmax = 100.0;\n \n float t = tmin;\n for ( int i = 0; i< 128; i++ ){\n res = map( ro + t * rd ).x;\n if ( res < precis || t > tmax ) break;\n t += res * 1.0;\n }\n \n if ( t > tmax ) t = -1.0;\n return t;\n }\n \n \n \n void main( void ) {\n \n vec3 ld = lightloc; //vec3( 1.0, -1.0, 2 );\n ld = normalize( ld );\n rd = normalize( rd );\n vec3 color = vec3( 0.0 );\n \n float t = raymarching( ro, rd );\n \n //Caculate the normal vector.\n vec3 n = getNormal( ro + t * rd );\n vec3 hit = ro + t * rd;\n vec2 res = map( hit );\n //Caculate diffuse.\n vec3 diff = diffuse * dot( n, -ld ) * 10.0 * abs(sin( res.y ) ) ;\n \n //Caculate sepc.\n vec3 spec = specc * pow(  max( 0.0, dot( -rd,  reflect( ld , n ) ) ), 13.0 );\n if (res.y == 1.0){\n spec = vec3( 0.0 );\n \n if ( mod( floor( hit.x * 4.0 ) , 2.0 ) == 0.0 || mod( floor( hit.z * 4.0 ) , 2.0 ) == 0.0 ){\n diff = vec3( 0.9, 0.7, 0.9 );\n }\n else{\n diff = vec3( 0.5 );\n }\n \n }\n \n color = diff + spec + ambient;\n \n \n gl_FragColor = vec4( color, 1.0 );\n }\n" };

    static const char * Light_Vertex[] = { " varying vec3 N;\n varying vec3 v;\n \n void main(void)\n {\n \n v = vec3(gl_ModelViewMatrix * gl_Vertex);\n N = normalize(gl_NormalMatrix * gl_Normal);\n \n //gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n gl_Position = gl_Vertex;\n }\n" };

    static const char * VertexPassthrough[] = { " layout(location = 0) in vec4 in_position;\n \n void main()\n {\n gl_Position = in_position;\n }\n" };

};

#endif
